import {
  __commonJS
} from "./chunk-MF7N2UXY.js";

// ../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/compat.js
var require_compat = __commonJS({
  "../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/compat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.startsWith = startsWith;
    exports.endsWith = endsWith;
    exports.stringIncludes = stringIncludes;
    exports.isRealNaN = isRealNaN;
    exports.arrayIncludes = arrayIncludes;
    function startsWith(str, searchString, position) {
      return str.substr(position || 0, searchString.length) === searchString;
    }
    function endsWith(str, searchString, position) {
      var index = (position || str.length) - searchString.length;
      var lastIndex = str.lastIndexOf(searchString, index);
      return lastIndex !== -1 && lastIndex === index;
    }
    function stringIncludes(str, searchString, position) {
      return str.indexOf(searchString, position || 0) !== -1;
    }
    function isRealNaN(x) {
      return typeof x === "number" && isNaN(x);
    }
    function arrayIncludes(array, searchElement, position) {
      var len = array.length;
      if (len === 0)
        return false;
      var lookupIndex = position | 0;
      var isNaNElement = isRealNaN(searchElement);
      var searchIndex = lookupIndex >= 0 ? lookupIndex : len + lookupIndex;
      while (searchIndex < len) {
        var element = array[searchIndex++];
        if (element === searchElement)
          return true;
        if (isNaNElement && isRealNaN(element))
          return true;
      }
      return false;
    }
  }
});

// ../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/lexer.js
var require_lexer = __commonJS({
  "../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/lexer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.feedPosition = feedPosition;
    exports.jumpPosition = jumpPosition;
    exports.makeInitialPosition = makeInitialPosition;
    exports.copyPosition = copyPosition;
    exports.default = lexer;
    exports.lex = lex;
    exports.findTextEnd = findTextEnd;
    exports.lexText = lexText;
    exports.lexComment = lexComment;
    exports.lexTag = lexTag;
    exports.isWhitespaceChar = isWhitespaceChar;
    exports.lexTagName = lexTagName;
    exports.lexTagAttributes = lexTagAttributes;
    exports.lexSkipTag = lexSkipTag;
    var _compat = require_compat();
    function feedPosition(position, str, len) {
      var start = position.index;
      var end = position.index = start + len;
      for (var i = start; i < end; i++) {
        var char = str.charAt(i);
        if (char === "\n") {
          position.line++;
          position.column = 0;
        } else {
          position.column++;
        }
      }
    }
    function jumpPosition(position, str, end) {
      var len = end - position.index;
      return feedPosition(position, str, len);
    }
    function makeInitialPosition() {
      return {
        index: 0,
        column: 0,
        line: 0
      };
    }
    function copyPosition(position) {
      return {
        index: position.index,
        line: position.line,
        column: position.column
      };
    }
    function lexer(str, options) {
      var state = {
        str,
        options,
        position: makeInitialPosition(),
        tokens: []
      };
      lex(state);
      return state.tokens;
    }
    function lex(state) {
      var str = state.str, childlessTags = state.options.childlessTags;
      var len = str.length;
      while (state.position.index < len) {
        var start = state.position.index;
        lexText(state);
        if (state.position.index === start) {
          var isComment = (0, _compat.startsWith)(str, "!--", start + 1);
          if (isComment) {
            lexComment(state);
          } else {
            var tagName = lexTag(state);
            var safeTag = tagName.toLowerCase();
            if ((0, _compat.arrayIncludes)(childlessTags, safeTag)) {
              lexSkipTag(tagName, state);
            }
          }
        }
      }
    }
    var alphanumeric = /[A-Za-z0-9]/;
    function findTextEnd(str, index) {
      while (true) {
        var textEnd = str.indexOf("<", index);
        if (textEnd === -1) {
          return textEnd;
        }
        var char = str.charAt(textEnd + 1);
        if (char === "/" || char === "!" || alphanumeric.test(char)) {
          return textEnd;
        }
        index = textEnd + 1;
      }
    }
    function lexText(state) {
      var type = "text";
      var str = state.str, position = state.position;
      var textEnd = findTextEnd(str, position.index);
      if (textEnd === position.index)
        return;
      if (textEnd === -1) {
        textEnd = str.length;
      }
      var start = copyPosition(position);
      var content = str.slice(position.index, textEnd);
      jumpPosition(position, str, textEnd);
      var end = copyPosition(position);
      state.tokens.push({ type, content, position: { start, end } });
    }
    function lexComment(state) {
      var str = state.str, position = state.position;
      var start = copyPosition(position);
      feedPosition(position, str, 4);
      var contentEnd = str.indexOf("-->", position.index);
      var commentEnd = contentEnd + 3;
      if (contentEnd === -1) {
        contentEnd = commentEnd = str.length;
      }
      var content = str.slice(position.index, contentEnd);
      jumpPosition(position, str, commentEnd);
      state.tokens.push({
        type: "comment",
        content,
        position: {
          start,
          end: copyPosition(position)
        }
      });
    }
    function lexTag(state) {
      var str = state.str, position = state.position;
      {
        var secondChar = str.charAt(position.index + 1);
        var close = secondChar === "/";
        var start = copyPosition(position);
        feedPosition(position, str, close ? 2 : 1);
        state.tokens.push({ type: "tag-start", close, position: { start } });
      }
      var tagName = lexTagName(state);
      lexTagAttributes(state);
      {
        var firstChar = str.charAt(position.index);
        var _close = firstChar === "/";
        feedPosition(position, str, _close ? 2 : 1);
        var end = copyPosition(position);
        state.tokens.push({ type: "tag-end", close: _close, position: { end } });
      }
      return tagName;
    }
    var whitespace = /\s/;
    function isWhitespaceChar(char) {
      return whitespace.test(char);
    }
    function lexTagName(state) {
      var str = state.str, position = state.position;
      var len = str.length;
      var start = position.index;
      while (start < len) {
        var char = str.charAt(start);
        var isTagChar = !(isWhitespaceChar(char) || char === "/" || char === ">");
        if (isTagChar)
          break;
        start++;
      }
      var end = start + 1;
      while (end < len) {
        var _char = str.charAt(end);
        var _isTagChar = !(isWhitespaceChar(_char) || _char === "/" || _char === ">");
        if (!_isTagChar)
          break;
        end++;
      }
      jumpPosition(position, str, end);
      var tagName = str.slice(start, end);
      state.tokens.push({
        type: "tag",
        content: tagName
      });
      return tagName;
    }
    function lexTagAttributes(state) {
      var str = state.str, position = state.position, tokens = state.tokens;
      var cursor = position.index;
      var quote = null;
      var wordBegin = cursor;
      var words = [];
      var len = str.length;
      while (cursor < len) {
        var char = str.charAt(cursor);
        if (quote) {
          var isQuoteEnd = char === quote;
          if (isQuoteEnd) {
            quote = null;
          }
          cursor++;
          continue;
        }
        var isTagEnd = char === "/" || char === ">";
        if (isTagEnd) {
          if (cursor !== wordBegin) {
            words.push(str.slice(wordBegin, cursor));
          }
          break;
        }
        var isWordEnd = isWhitespaceChar(char);
        if (isWordEnd) {
          if (cursor !== wordBegin) {
            words.push(str.slice(wordBegin, cursor));
          }
          wordBegin = cursor + 1;
          cursor++;
          continue;
        }
        var isQuoteStart = char === "'" || char === '"';
        if (isQuoteStart) {
          quote = char;
          cursor++;
          continue;
        }
        cursor++;
      }
      jumpPosition(position, str, cursor);
      var wLen = words.length;
      var type = "attribute";
      for (var i = 0; i < wLen; i++) {
        var word = words[i];
        var isNotPair = word.indexOf("=") === -1;
        if (isNotPair) {
          var secondWord = words[i + 1];
          if (secondWord && (0, _compat.startsWith)(secondWord, "=")) {
            if (secondWord.length > 1) {
              var newWord = word + secondWord;
              tokens.push({ type, content: newWord });
              i += 1;
              continue;
            }
            var thirdWord = words[i + 2];
            i += 1;
            if (thirdWord) {
              var _newWord = word + "=" + thirdWord;
              tokens.push({ type, content: _newWord });
              i += 1;
              continue;
            }
          }
        }
        if ((0, _compat.endsWith)(word, "=")) {
          var _secondWord = words[i + 1];
          if (_secondWord && !(0, _compat.stringIncludes)(_secondWord, "=")) {
            var _newWord3 = word + _secondWord;
            tokens.push({ type, content: _newWord3 });
            i += 1;
            continue;
          }
          var _newWord2 = word.slice(0, -1);
          tokens.push({ type, content: _newWord2 });
          continue;
        }
        tokens.push({ type, content: word });
      }
    }
    var push = [].push;
    function lexSkipTag(tagName, state) {
      var str = state.str, position = state.position, tokens = state.tokens;
      var safeTagName = tagName.toLowerCase();
      var len = str.length;
      var index = position.index;
      while (index < len) {
        var nextTag = str.indexOf("</", index);
        if (nextTag === -1) {
          lexText(state);
          break;
        }
        var tagStartPosition = copyPosition(position);
        jumpPosition(tagStartPosition, str, nextTag);
        var tagState = { str, position: tagStartPosition, tokens: [] };
        var name = lexTag(tagState);
        if (safeTagName !== name.toLowerCase()) {
          index = tagState.position.index;
          continue;
        }
        if (nextTag !== position.index) {
          var textStart = copyPosition(position);
          jumpPosition(position, str, nextTag);
          tokens.push({
            type: "text",
            content: str.slice(textStart.index, nextTag),
            position: {
              start: textStart,
              end: copyPosition(position)
            }
          });
        }
        push.apply(tokens, tagState.tokens);
        jumpPosition(position, str, tagState.position.index);
        break;
      }
    }
  }
});

// ../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/parser.js
var require_parser = __commonJS({
  "../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = parser;
    exports.hasTerminalParent = hasTerminalParent;
    exports.rewindStack = rewindStack;
    exports.parse = parse;
    var _compat = require_compat();
    function parser(tokens, options) {
      var root = { tagName: null, children: [] };
      var state = { tokens, options, cursor: 0, stack: [root] };
      parse(state);
      return root.children;
    }
    function hasTerminalParent(tagName, stack, terminals) {
      var tagParents = terminals[tagName];
      if (tagParents) {
        var currentIndex = stack.length - 1;
        while (currentIndex >= 0) {
          var parentTagName = stack[currentIndex].tagName;
          if (parentTagName === tagName) {
            break;
          }
          if ((0, _compat.arrayIncludes)(tagParents, parentTagName)) {
            return true;
          }
          currentIndex--;
        }
      }
      return false;
    }
    function rewindStack(stack, newLength, childrenEndPosition, endPosition) {
      stack[newLength].position.end = endPosition;
      for (var i = newLength + 1, len = stack.length; i < len; i++) {
        stack[i].position.end = childrenEndPosition;
      }
      stack.splice(newLength);
    }
    function parse(state) {
      var tokens = state.tokens, options = state.options;
      var stack = state.stack;
      var nodes = stack[stack.length - 1].children;
      var len = tokens.length;
      var cursor = state.cursor;
      while (cursor < len) {
        var token = tokens[cursor];
        if (token.type !== "tag-start") {
          nodes.push(token);
          cursor++;
          continue;
        }
        var tagToken = tokens[++cursor];
        cursor++;
        var tagName = tagToken.content.toLowerCase();
        if (token.close) {
          var index = stack.length;
          var shouldRewind = false;
          while (--index > -1) {
            if (stack[index].tagName === tagName) {
              shouldRewind = true;
              break;
            }
          }
          while (cursor < len) {
            var endToken = tokens[cursor];
            if (endToken.type !== "tag-end")
              break;
            cursor++;
          }
          if (shouldRewind) {
            rewindStack(stack, index, token.position.start, tokens[cursor - 1].position.end);
            break;
          } else {
            continue;
          }
        }
        var isClosingTag = (0, _compat.arrayIncludes)(options.closingTags, tagName);
        var shouldRewindToAutoClose = isClosingTag;
        if (shouldRewindToAutoClose) {
          var terminals = options.closingTagAncestorBreakers;
          shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals);
        }
        if (shouldRewindToAutoClose) {
          var currentIndex = stack.length - 1;
          while (currentIndex > 0) {
            if (tagName === stack[currentIndex].tagName) {
              rewindStack(stack, currentIndex, token.position.start, token.position.start);
              var previousIndex = currentIndex - 1;
              nodes = stack[previousIndex].children;
              break;
            }
            currentIndex = currentIndex - 1;
          }
        }
        var attributes = [];
        var attrToken = void 0;
        while (cursor < len) {
          attrToken = tokens[cursor];
          if (attrToken.type === "tag-end")
            break;
          attributes.push(attrToken.content);
          cursor++;
        }
        cursor++;
        var children = [];
        var position = {
          start: token.position.start,
          end: attrToken.position.end
        };
        var elementNode = {
          type: "element",
          tagName: tagToken.content,
          attributes,
          children,
          position
        };
        nodes.push(elementNode);
        var hasChildren = !(attrToken.close || (0, _compat.arrayIncludes)(options.voidTags, tagName));
        if (hasChildren) {
          var size = stack.push({ tagName, children, position });
          var innerState = { tokens, options, cursor, stack };
          parse(innerState);
          cursor = innerState.cursor;
          var rewoundInElement = stack.length === size;
          if (rewoundInElement) {
            elementNode.position.end = tokens[cursor - 1].position.end;
          }
        }
      }
      state.cursor = cursor;
    }
  }
});

// ../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/format.js
var require_format = __commonJS({
  "../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.splitHead = splitHead;
    exports.unquote = unquote;
    exports.format = format;
    exports.formatAttributes = formatAttributes;
    function splitHead(str, sep) {
      var idx = str.indexOf(sep);
      if (idx === -1)
        return [str];
      return [str.slice(0, idx), str.slice(idx + sep.length)];
    }
    function unquote(str) {
      var car = str.charAt(0);
      var end = str.length - 1;
      var isQuoteStart = car === '"' || car === "'";
      if (isQuoteStart && car === str.charAt(end)) {
        return str.slice(1, end);
      }
      return str;
    }
    function format(nodes, options) {
      return nodes.map(function(node) {
        var type = node.type;
        var outputNode = type === "element" ? {
          type,
          tagName: node.tagName.toLowerCase(),
          attributes: formatAttributes(node.attributes),
          children: format(node.children, options)
        } : { type, content: node.content };
        if (options.includePositions) {
          outputNode.position = node.position;
        }
        return outputNode;
      });
    }
    function formatAttributes(attributes) {
      return attributes.map(function(attribute) {
        var parts = splitHead(attribute.trim(), "=");
        var key = parts[0];
        var value = typeof parts[1] === "string" ? unquote(parts[1]) : null;
        return { key, value };
      });
    }
  }
});

// ../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.formatAttributes = formatAttributes;
    exports.toHTML = toHTML;
    var _compat = require_compat();
    function formatAttributes(attributes) {
      return attributes.reduce(function(attrs, attribute) {
        var key = attribute.key, value = attribute.value;
        if (value === null) {
          return attrs + " " + key;
        }
        var quoteEscape = value.indexOf("'") !== -1;
        var quote = quoteEscape ? '"' : "'";
        return attrs + " " + key + "=" + quote + value + quote;
      }, "");
    }
    function toHTML(tree, options) {
      return tree.map(function(node) {
        if (node.type === "text") {
          return node.content;
        }
        if (node.type === "comment") {
          return "<!--" + node.content + "-->";
        }
        var tagName = node.tagName, attributes = node.attributes, children = node.children;
        var isSelfClosing = (0, _compat.arrayIncludes)(options.voidTags, tagName.toLowerCase());
        return isSelfClosing ? "<" + tagName + formatAttributes(attributes) + ">" : "<" + tagName + formatAttributes(attributes) + ">" + toHTML(children, options) + "</" + tagName + ">";
      }).join("");
    }
    exports.default = { toHTML };
  }
});

// ../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/tags.js
var require_tags = __commonJS({
  "../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/tags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var childlessTags = exports.childlessTags = ["style", "script", "template"];
    var closingTags = exports.closingTags = ["html", "head", "body", "p", "dt", "dd", "li", "option", "thead", "th", "tbody", "tr", "td", "tfoot", "colgroup"];
    var closingTagAncestorBreakers = exports.closingTagAncestorBreakers = {
      li: ["ul", "ol", "menu"],
      dt: ["dl"],
      dd: ["dl"],
      tbody: ["table"],
      thead: ["table"],
      tfoot: ["table"],
      tr: ["table"],
      td: ["table"]
    };
    var voidTags = exports.voidTags = ["!doctype", "area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
  }
});

// ../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/himalaya@1.1.0/node_modules/himalaya/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseDefaults = void 0;
    exports.parse = parse;
    exports.stringify = stringify;
    var _lexer = require_lexer();
    var _lexer2 = _interopRequireDefault(_lexer);
    var _parser = require_parser();
    var _parser2 = _interopRequireDefault(_parser);
    var _format = require_format();
    var _stringify = require_stringify();
    var _tags = require_tags();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var parseDefaults = exports.parseDefaults = {
      voidTags: _tags.voidTags,
      closingTags: _tags.closingTags,
      childlessTags: _tags.childlessTags,
      closingTagAncestorBreakers: _tags.closingTagAncestorBreakers,
      includePositions: false
    };
    function parse(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : parseDefaults;
      var tokens = (0, _lexer2.default)(str, options);
      var nodes = (0, _parser2.default)(tokens, options);
      return (0, _format.format)(nodes, options);
    }
    function stringify(ast) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : parseDefaults;
      return (0, _stringify.toHTML)(ast, options);
    }
  }
});

// dep:himalaya
var himalaya_default = require_lib();
export {
  himalaya_default as default
};
//# sourceMappingURL=himalaya.js.map
